<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chaos</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zranbo.com/"/>
  <updated>2019-05-17T15:31:30.432Z</updated>
  <id>https://www.zranbo.com/</id>
  
  <author>
    <name>zranbo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo 标签插件</title>
    <link href="https://www.zranbo.com/item/b32026b8/"/>
    <id>https://www.zranbo.com/item/b32026b8/</id>
    <published>2019-05-17T15:06:00.000Z</published>
    <updated>2019-05-17T15:31:30.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo内置"><a href="#Hexo内置" class="headerlink" title="Hexo内置"></a>Hexo内置</h1><p><b>引用块 (blockquote)</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><hr><p><b>Pull Quote</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><blockquote class="pullquote Wide Awake"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p></blockquote><h1 id="NexT-内置"><a href="#NexT-内置" class="headerlink" title="NexT 内置"></a>NexT 内置</h1><p><b>Bootstrap Callout</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] %&#125; Content &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>class为一下之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">primary</span><br><span class="line">success</span><br><span class="line">info</span><br><span class="line">warning</span><br><span class="line">danger</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><div class="note default"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note primary"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note success"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note info"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note warning"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note danger"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo内置&quot;&gt;&lt;a href=&quot;#Hexo内置&quot; class=&quot;headerlink&quot; title=&quot;Hexo内置&quot;&gt;&lt;/a&gt;Hexo内置&lt;/h1&gt;&lt;p&gt;&lt;b&gt;引用块 (blockquote)&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://www.zranbo.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python - 序列构成的数组 (二)</title>
    <link href="https://www.zranbo.com/item/2e88435f/"/>
    <id>https://www.zranbo.com/item/2e88435f/</id>
    <published>2019-05-15T09:01:00.000Z</published>
    <updated>2019-05-17T14:48:52.295Z</updated>
    
    <content type="html"><![CDATA[<p><b>序列类型概念</b></p><p>谈起序列，我们能说的就有很多了，比如我们很常用的<code>str</code> , <code>list</code> , <code>tuple</code> 等，Python用C语言实现了丰富的序列类型：</p><ul><li><p>容器序列（这些序列可以存放不同类型的数据）</p><p><code>list</code> <code>tuple</code> 等</p></li><li><p>扁平序列（这些序列只能存放同一种类型数据）</p><p><code>str</code> <code>bytes</code> <code>bytearray</code> <code>memoryview</code> <code>array.array</code> 等</p><p>这里需要注意一下点的是，对于容器序列，里面存放的是任意类型的对象的<b>引用</b>，而扁平序列是一串连续的内存空间，保存的是这些数据的值。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val = [<span class="number">1</span>]</span><br><span class="line">ctn = [val]</span><br><span class="line"></span><br><span class="line">print(ctn)</span><br><span class="line">val.append(<span class="number">2</span>)</span><br><span class="line">print(ctn)</span><br></pre></td></tr></table></figure><p><b>列表推导式</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"hello world"</span></span><br><span class="line">lst = [x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> string]</span><br></pre></td></tr></table></figure></p><p>这是一个很简单的列表推导式，当然，如果我们需要一些复杂的东西，可以这样变化一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'pink'</span>]</span><br><span class="line">sizes = [<span class="string">'M'</span>, <span class="string">'L'</span>, <span class="string">'XL'</span>]</span><br><span class="line"></span><br><span class="line">goods = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line">print(goods)</span><br><span class="line">goods = [(color, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes <span class="keyword">for</span> color <span class="keyword">in</span> colors]</span><br><span class="line">print(goods)</span><br></pre></td></tr></table></figure><p>调换了一下后面迭代的先后顺序，可以看到结果有了变化。</p><p><b>生成器表达式</b></p><p>从使用上来说，和列表推导式没有太大的区别，只是将<code>[ ]</code>换成<code>( )</code>。<br>列表推导式最终得到的是一个列表对象，而生成器表达式是一个元组对象。</p><p><b>元组不仅仅是不可变的列表</b></p><p>元组的一个特殊之处是对象一旦被创建，就不能更改，包括值和值所在的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">t2 = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">t3 = (<span class="string">'b'</span>, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">print(t1 <span class="keyword">is</span> t2)</span><br><span class="line">print(t1 <span class="keyword">is</span> t3)</span><br></pre></td></tr></table></figure><p>正因为这个，元组就变得有点意思了，因为除了具体的值，元组还可以比列表多记录一项内容：这些数据的位置也可以用来保存一定的信息。</p><p><b>序列的拆包</b></p><p>注意这里我们并没有用元组的拆包，那是因为并不是只有元组才能拆包，而是一般的，对于大多数Python的序列，我们都可以这要去做<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eg = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">ele1, ele2, ele3 = eg</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">egl = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">ele1, ele2, ele3 = egl</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">eg2 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">ele1, ele2, ele3 = eg2</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">eg3 = <span class="string">'abc'</span></span><br><span class="line">ele1, ele2, ele3 = eg3</span><br><span class="line">print(ele1, ele2, ele3)</span><br></pre></td></tr></table></figure></p><p>值得注意的一点是，对于字典 <code>dict</code> 的拆包，并不是把 <code>key-value</code> 这个键值对拿出来了，而只是把 <code>key</code> 拆开了，其实对于这个我们一点也不惊讶，毕竟如果我们需要对字典的 <code>key-value</code> 都进行迭代，并不是 <code>for data in dict</code> 而是 <code>for k, v in dict.items()</code> 注意观察到其实我们也发现了，这里不就是用了对字典的 <code>key-value</code> 拆包的方法么？</p><p><b>序列拆包中 <code>*</code> 的作用</b></p><p>对于拆包过程中，我们可以使用 <code>*</code> 来包含多个元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>)</span><br><span class="line">ele1, ele2, *eles = t</span><br><span class="line">print(ele1, ele2, eles)</span><br></pre></td></tr></table></figure></p><p>而 <code>*</code> 表示的多个元素则会放到一个列表中去。</p><p>而且这个 <code>*</code> 可以放到中间表示出了首末若干元素的其他所有元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>)</span><br><span class="line">ele1, ele2, *eles, ele3 = t</span><br><span class="line">print(ele1, ele2, eles, ele3)</span><br></pre></td></tr></table></figure></p><p><b>元组和列表的区别</b></p><p>这里的区别体现在一些内置的属性方法上。列表说明</p><table><thead><tr><th style="text-align:center">属性方法</th><th style="text-align:center">说明</th><th style="text-align:center">列表</th><th style="text-align:center">元组</th></tr></thead><tbody><tr><td style="text-align:center"><code>s.__getnewargs__()</code></td><td style="text-align:center"><code>pickle</code> 中支持更加优化的序列化</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__add__(s2)</code></td><td style="text-align:center"><code>s + s2</code>，拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__contains__(e)</code></td><td style="text-align:center"><code>s</code> 是否包含 <code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.index(e)</code></td><td style="text-align:center">在 <code>s</code> 中找到元素 <code>e</code> 第一次出现的位置</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.count(e)</code></td><td style="text-align:center"><code>e</code> 在 <code>s</code> 中出现的次数</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__getitem__(p)</code></td><td style="text-align:center"><code>s[p]</code>，获取位置 <code>p</code> 的元素</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__iter__()</code></td><td style="text-align:center">获取 <code>s</code> 的迭代器</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__len__()</code></td><td style="text-align:center"><code>len(s)</code>，元素的数量</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__mul__(n)</code></td><td style="text-align:center"><code>s * n</code>，<code>n</code> 个 <code>s</code> 的重复拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__rmul__(n)</code></td><td style="text-align:center"><code>n * s</code>，反向拼接 *</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__delitem__(p)</code></td><td style="text-align:center">把位于 <code>p</code> 的元素删除</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__reversed__()</code></td><td style="text-align:center">返回 <code>s</code> 的倒序迭代器</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__setitem__(p, e)</code></td><td style="text-align:center"><code>s[p] = e</code>，把元素 <code>e</code> 放在位置 <code>p</code>，替代已经在那个位置的元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__imul__(n)</code></td><td style="text-align:center"><code>s *= n</code>，就地重复拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__iadd__(s2)</code></td><td style="text-align:center"><code>s += s2</code>，就地拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.insert(p, e)</code></td><td style="text-align:center">在位置 <code>p</code> 之前插入元素<code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.append(e)</code></td><td style="text-align:center">在尾部添加一个新元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.clear()</code></td><td style="text-align:center">删除所有元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.copy()</code></td><td style="text-align:center">浅复制</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.extend(it)</code></td><td style="text-align:center">把可迭代对象 <code>it</code> 追加给 <code>s</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.pop([p])</code></td><td style="text-align:center">删除最后或者是（可选的）位于 <code>p</code> 的元素，并返回它的值</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.remove(e)</code></td><td style="text-align:center">删除 <code>s</code> 中的第一次出现的 <code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.reverse()</code></td><td style="text-align:center">就地倒序</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.sort([key], [reverse])</code></td><td style="text-align:center">就地对 <code>s</code> 中的元素进行排序，可选的参数有键（<code>key</code>）和是否倒序（<code>reverse</code>）</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;序列类型概念&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;谈起序列，我们能说的就有很多了，比如我们很常用的&lt;code&gt;str&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;tuple&lt;/code&gt; 等，Python用C语言实现了丰富的序列类型：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://www.zranbo.com/tags/Fluent-Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python - Python数据模型 (一)</title>
    <link href="https://www.zranbo.com/item/1bbbb445/"/>
    <id>https://www.zranbo.com/item/1bbbb445/</id>
    <published>2019-05-14T06:03:00.000Z</published>
    <updated>2019-05-17T14:59:19.076Z</updated>
    
    <content type="html"><![CDATA[<p><b>Magic Method (Dunder Method)</b></p><div class="note info"><p>Python 里面有很多特殊方法，我们管他叫魔术方法(magic method)。之所以特殊，是因为这些方法不同于一般的对象方法的调用方式 <code>Object.function</code>，比如对于获取字符串对象 <code>s = &quot;Hello&quot;</code> 的长度,不同于其他一些语言的 <code>s.length()</code> 或者类似的方法，Python采用 <code>len(s)</code> 这样的形式。 </p></div><blockquote><p>首先明确一点，特殊方法的存在是为了被 Python 解释器调用的，你自己并不需要调用它们。也就是说没有 <code>my_object.__len__()</code> 这种写法，而应该使用 <code>len(my_object</code>)。在执行 <code>len(my_object)</code> 的时候，如果 <code>my_object</code> 是一个自定义类的对象，那么 Python 会自己去调用其中由你实现的 <code>__len__</code> 方法。</p><footer><strong>——Fluent Python</strong></footer></blockquote><p>而 Python 里面这样的特殊方法还有很多，列一个表格说明一些。</p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:center">字符串/字节序列表示形式</td><td style="text-align:left"><code>__repr__</code>、<code>__str__</code>、<code>__format__</code>、<code>__bytes__</code></td></tr><tr><td style="text-align:center">数值转换</td><td style="text-align:left"><code>__abs__</code>、<code>__bool__</code>、<code>__complex__</code>、<code>__int__</code>、<code>__float__</code>、<code>__hash__</code>、<code>__index__</code></td></tr><tr><td style="text-align:center">集合模拟</td><td style="text-align:left"><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td></tr><tr><td style="text-align:center">迭代枚举</td><td style="text-align:left"><code>__iter__</code>、<code>__reversed__</code>、<code>__next__</code></td></tr><tr><td style="text-align:center">可调用模拟</td><td style="text-align:left"><code>__call__</code></td></tr><tr><td style="text-align:center">上下文管理</td><td style="text-align:left"><code>__enter__</code>、<code>__exit__</code></td></tr><tr><td style="text-align:center">实例创建和销毁</td><td style="text-align:left"><code>__new__</code>、<code>__init__</code>、<code>__del__</code></td></tr><tr><td style="text-align:center">属性管理</td><td style="text-align:left"><code>__getattr__</code>、<code>__getattribute__</code>、<code>__setattr__</code>、<code>__delattr__</code>、<code>__dir__</code></td></tr><tr><td style="text-align:center">属性描述符</td><td style="text-align:left"><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td></tr><tr><td style="text-align:center">类相关服务</td><td style="text-align:left"><code>__prepare__</code>、<code>__instancecheck__</code>、<code>__subclasscheck__</code></td></tr></tbody></table><p>上面表格里面列举的并不是所有的，还有很多比如与运算相关的特殊方法 <code>__add__</code> 、 <code>__abs__</code> 等都没有列举。</p><p><b>一些常用操作对应的魔术方法</b></p><ul><li><p><code>for</code> 迭代操作</p><p>如果一个对象可以通过 <code>for</code> 循环，需要实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法，并且需要在 <code>__next__()</code> 中通过抛出 <code>StopIteration</code> 异常来控制 <code>for</code> 的终止行为:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init=<span class="number">0</span>, stop=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.init = init</span><br><span class="line">        self.data = init</span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.data &gt;= self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data</span><br><span class="line">            </span><br><span class="line">obj = tObject()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><ul><li><p><code>in</code> 操作</p><p>用 <code>in</code> 判断对象关系的时候，需要实现 <code>__contains__()</code>，但是如果没有实现 <code>__contains__()</code> ，会进行一次迭代操作：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init=<span class="number">0</span>, stop=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.init = init</span><br><span class="line">        self.data = init</span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.data &gt;= self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.init &lt; key &lt; self.stop:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">obj = tObject()</span><br><span class="line"></span><br><span class="line">print(<span class="number">5</span> <span class="keyword">in</span> obj)</span><br></pre></td></tr></table></figure><p>但是如果没有实现 <code>__contains__()</code> 这里这里就会首先进行一次迭代操作，然后去判断。</p><ul><li><p><code>print()</code>或<code>str()</code></p><p><code>__repr__()</code>的目的应该是能准确表达出对象。</p><p><code>__str__()</code>的目的是能友好的可读的表达对象。</p></li></ul><ul><li><p><code>[]</code> 取值&amp;赋值&amp;操作</p><p>分别是 <code>__getitem__()</code> 和 <code>__setitem__()</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data.get(key, <span class="string">'N/A'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        self.data[key] = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = tObject()</span><br><span class="line">obj[<span class="string">'1'</span>] = <span class="string">'a'</span></span><br><span class="line">print(obj[<span class="string">'1'</span>])</span><br></pre></td></tr></table></figure><p><code>__getitem__()</code> 方法用于返回参数 <code>key</code> 所对应的值，这个 <code>key</code> 可以是索引，关键字或切片对象，并且支持负数索引；如果 <code>key</code> 不是以上两种类型，就会抛出 <code>TypeError</code> ；如果索引越界，会抛 <code>IndexError</code> ；如果定义的是映射类型，当 <code>key</code> 参数不是其对象的键值时，则会抛出 <code>KeyError</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;Magic Method (Dunder Method)&lt;/b&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Python 里面有很多特殊方法，我们管他叫魔术方法(magic method)。之所以特殊，是因为这些方法不同于一般的对象方法的调用方式 &lt;
      
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://www.zranbo.com/tags/Fluent-Python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.zranbo.com/item/4a17b156/"/>
    <id>https://www.zranbo.com/item/4a17b156/</id>
    <published>2019-05-05T09:52:00.000Z</published>
    <updated>2019-05-17T14:48:52.293Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Void" scheme="https://www.zranbo.com/tags/Void/"/>
    
  </entry>
  
</feed>
