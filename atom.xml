<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chaos</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zranbo.com/"/>
  <updated>2019-05-28T11:14:47.370Z</updated>
  <id>https://www.zranbo.com/</id>
  
  <author>
    <name>zranbo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux/Unix进程管理工具 - Supervisor</title>
    <link href="https://www.zranbo.com/item/1f6c73c0/"/>
    <id>https://www.zranbo.com/item/1f6c73c0/</id>
    <published>2019-05-28T08:40:00.000Z</published>
    <updated>2019-05-28T11:14:47.370Z</updated>
    
    <content type="html"><![CDATA[<p><b>Supervisor</b></p><p><a href="http://supervisord.org/" target="_blank" rel="noopener"><code>Supervisor</code></a> 是一个用 <code>Python2</code> 实现的 Unix-like 系统进程管理工具。</p><p><b>安装</b></p><ol><li>Ubuntu : <code>apt install supervisor</code></li><li>其他 Linux 发行版: <code>pip install supervisor</code> (只支持 <code>Python2</code> 因此请确定是<code>Python2</code>的<code>pip</code>)</li></ol><p>安装完成后会生成三个执行程序：<code>supervisortd</code> <code>supervisorctl</code> <code>echo_supervisord_conf</code> 分别是：守护进程服务、客户端、初始配置文件程序。</p><p><b>配置</b></p><p>运行 <code>supervisord</code> 要指定 <code>supervisor</code> 配置文件,默认在以下目录查找：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure></p><p>并且可以通过 <code>echo_supervisord_conf</code> 生成一份 <code>supervisor</code> 配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure></p><p><b>主程序配置文件说明</b></p><p>注释：以分号 <code>;</code> 开头的表示注释行<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/tmp/supervisor.sock; UNIX socket 文件，supervisorctl要用</span><br><span class="line"><span class="comment">;chmod=0700; socket文件的权限，默认是0700</span></span><br><span class="line"><span class="comment">;chown=nobody:nogroup; socket文件的 owner，格式：uid:gid</span></span><br><span class="line"><span class="comment">;username=user; 登录管理后台的用户名</span></span><br><span class="line"><span class="comment">;password=123; 登录管理后台的密码</span></span><br><span class="line"></span><br><span class="line"><span class="section">[inet_http_server]</span><span class="comment">; HTTP服务，提供Web端管理界面</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span>; Web管理后台运行的IP和端口</span><br><span class="line"><span class="attr">username</span>=user; 登录管理后台的用户名</span><br><span class="line"><span class="attr">password</span>=<span class="number">123</span>; 登录管理后台的密码</span><br><span class="line"></span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/supervisord.log ; 主程序的日志文件</span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        ; 主程序日志大小，默认 <span class="number">50</span>MB，<span class="number">0</span>，表示不限制</span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           ; 主程序日志备份数量，默认<span class="number">10</span>，<span class="number">0</span>，表示不备份</span><br><span class="line"><span class="attr">loglevel</span>=info                ; 主程序日志级别，默认 info，其它: debug,warn,trace</span><br><span class="line"><span class="attr">pidfile</span>=/tmp/supervisord.pid ; supervisord pid 文件; 默认 supervisord.pid</span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               ; 是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                  ; 可以打开的文件描述符的最小值，默认 <span class="number">1024</span></span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>                 ; 可以打开的进程数的最小值，默认 <span class="number">200</span></span><br><span class="line"><span class="comment">;umask=022                   ; umask 022 创建新文件权限为755</span></span><br><span class="line"><span class="comment">;user=chrism                 ; 启动用户，默认为当前用户</span></span><br><span class="line"><span class="comment">;identifier=supervisor       ; supervisord 标识, 默认 `supervisor`</span></span><br><span class="line"><span class="comment">;directory=/tmp              ; 当 supervisord 守护进程时，切换到此目录</span></span><br><span class="line"><span class="comment">;nocleanup=true              ; 启动时清除子日志文件，默认 false</span></span><br><span class="line"><span class="comment">;childlogdir=/tmp            ; 子日志文件路径 默认为 $TEMP</span></span><br><span class="line"><span class="comment">;environment=KEY="value"     ; 添加环境变量到 supervisord 进程的环境中</span></span><br><span class="line"><span class="comment">;strip_ansi=false            ; 删除日志文件中所有ANSI转义序列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[rpcinterface:supervisor]</span></span><br><span class="line"><span class="attr">supervisor.rpcinterface_factory</span> = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///tmp/supervisor.sock; 通过UNIX socket 连接supervisord，与[unix_http_server]部分file一致</span><br><span class="line"><span class="comment">;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 方式连接 supervisord</span></span><br><span class="line"><span class="comment">;username=chris              ; 用于身份验证的用户名。与 supervisord 服务器配置的用户名相同</span></span><br><span class="line"><span class="comment">;password=123                ; 用于身份验证的密码。与 supervisord 服务器配置的密码的明文相同。</span></span><br><span class="line"><span class="comment">;prompt=mysupervisor         ; 用作 supervisorctl 提示符的字符串</span></span><br><span class="line"><span class="comment">;history_file=~/.sc_history  ; 用作 readline 持久性历史记录文件的路径</span></span><br><span class="line"></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/conf.d/*.ini ; 可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure></p><p><b>配置管理进程</b></p><p>进程管理配置参数，不建议全都写在 <code>supervisord.conf</code> 文件中，建议每个进程采用一个配置文件放到 <code>supervisord.conf</code> 配置中 <code>[include]</code>字段 <code>files</code> 指定的路径下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;[program:programname]; program:xxx (xxx 为自定义的管理的进程的名称名称，不可重复)</span></span><br><span class="line"><span class="comment">;command=/bin/cat; 程序启动命令 (该命令只能是前台任务命令)</span></span><br><span class="line"><span class="comment">;process_name=%(program_name)s; 进程名称</span></span><br><span class="line"><span class="comment">;numprocs=1; 进程数量 (默认为 1)</span></span><br><span class="line"><span class="comment">;directory=/tmp               ; 在执行 command 之前，supervisord 切换到的目录。</span></span><br><span class="line"><span class="comment">;autostart=true                ; supervisord 启动的时候也自动启动</span></span><br><span class="line"><span class="comment">;startsecs=1                   ; 启动1秒后没有异常退出，就表示进程正常启动了，默认为1秒</span></span><br><span class="line"><span class="comment">;startretries=3                ; 启动失败自动重试次数，默认是3次</span></span><br><span class="line"><span class="comment">;autorestart=unexpected        ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span></span><br><span class="line"><span class="comment">;stopasgroup=false             ; 进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span></span><br><span class="line"><span class="comment">;killasgroup=false             ; 进程组发送kill信号，包括子进程</span></span><br><span class="line"><span class="comment">;user=chrism                   ; 启动进程的用户</span></span><br><span class="line"><span class="comment">;redirect_stderr=false          ; 把stderr重定向到stdout，默认false</span></span><br><span class="line"><span class="comment">;stdout_logfile=/a/path        ; stdout 日志文件路径</span></span><br><span class="line"><span class="comment">;stdout_logfile_maxbytes=1MB   ; stdout 日志文件大小 0 表示无限制</span></span><br><span class="line"><span class="comment">;stdout_logfile_backups=10     ; stdout 日志文件备份数量 0 表示不备份</span></span><br><span class="line"><span class="comment">;stdout_capture_maxbytes=1MB   ; stdout 捕获模式 日志文件大小</span></span><br><span class="line"><span class="comment">;stderr_logfile=/a/path        ; stderr 日志文件路径</span></span><br><span class="line"><span class="comment">;stderr_logfile_maxbytes=1MB   ; stderr 日志文件大小 0 表示无限制</span></span><br><span class="line"><span class="comment">;stderr_logfile_backups=10     ; stderr 日志文件备份数量 0 表示不备份</span></span><br><span class="line"><span class="comment">;stderr_capture_maxbytes=1MB   ; stderr 捕获模式 日志文件大小</span></span><br><span class="line"><span class="comment">;environment=A="1",B="2"       ; 添加环境变量到子进程的环境中</span></span><br></pre></td></tr></table></figure><p><b>启动Supervisor服务</b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure><p><b>supervisorctl 管理进程</b></p><p>启动成功后，就可以通过 supervisorctl 管理进程。在 shell 中直接输入 <code>supervisorctl</code> 就可以直接进入交互式的环境中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> status<span class="comment"># 查看所有进程的状态</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> update<span class="comment"># 重启配置文件修改过的程序</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> reread<span class="comment"># 读取有更新（增加）的配置文件，不会启动新添加的程序</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> start program<span class="comment"># 启动 program 程序</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> stop program<span class="comment"># 停止 program 程序</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> restart program<span class="comment"># 重启 program 程序</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;Supervisor&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://supervisord.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; 是一个用 &lt;code&gt;Python2&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.zranbo.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python - 文本和字节序列 (四)</title>
    <link href="https://www.zranbo.com/item/d12c295b/"/>
    <id>https://www.zranbo.com/item/d12c295b/</id>
    <published>2019-05-27T13:01:00.000Z</published>
    <updated>2019-05-28T11:13:32.783Z</updated>
    
    <content type="html"><![CDATA[<p><b>字符问题</b></p><p>字符串本身是个字符序列。这个定义没有问题。但是问题出现在对于“字符”的定义上。对于现在来说，“字符”应该是一个 Unicode 字符。</p><p>Unicode 标准把字符的标识和具体的字节表述进行了如下的明确区分</p><ul><li>字符的标识，即码位，是 0~1 114 111 的数字（十进制），在 Unicode 标准中以 4~6 个 十六进制数字表示，而且加前缀“U+”。例如，字母 A 的码位是 U+0041，欧元符号的 码位是 U+20AC，高音谱号的码位是 U+1D11E。在 Unicode 6.3 中（这是 Python 3.4 使 用的标准），约 10% 的有效码位有对应的字符。</li><li>字符的具体表述取决于所用的编码。编码是在码位和字节序列之间转换时使用的算法。 在 UTF-8 编码中，A（U+0041）的码位编码成单个字节 \x41，而在 UTF-16LE 编码中 编码成两个字节 \x41\x00。再举个例子，欧元符号（U+20AC）在 UTF-8 编码中是三个 字节——\xe2\x82\xac，而在 UTF-16LE 中编码成两个字节 \xac\x20。</li></ul><p>把码位转换成字节序列的过程是编码；把字节序列转换成码位的过程是解码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"你好hello"</span></span><br><span class="line">print(s, len(s))</span><br><span class="line">b = s.encode(<span class="string">'utf8'</span>)</span><br><span class="line">print(b, len(b))</span><br><span class="line">print(b.decode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;字符问题&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;字符串本身是个字符序列。这个定义没有问题。但是问题出现在对于“字符”的定义上。对于现在来说，“字符”应该是一个 Unicode 字符。&lt;/p&gt;
&lt;p&gt;Unicode 标准把字符的标识和具体的字节表述进行了如下的明确区分&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://www.zranbo.com/tags/Fluent-Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python - 字典和集合 (三)</title>
    <link href="https://www.zranbo.com/item/3dd06891/"/>
    <id>https://www.zranbo.com/item/3dd06891/</id>
    <published>2019-05-18T04:26:00.000Z</published>
    <updated>2019-05-26T14:06:10.941Z</updated>
    
    <content type="html"><![CDATA[<p><b>泛映射类型</b> 抽象类：</p><p>在 collections.abc 模块中有 <b><a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mpping</code></a></b> 和 <b><a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>MutableMapping</code></a></b> 为 <code>dict</code> 和其他一些类提供了最基本的接口<br><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/dict-uml.png" alt></p><p><b>可散列类型</b></p><ul><li><code>str</code> <code>bytes</code> <code>frozenset</code>只能容纳可散列对象，<code>tuple</code> 只有当其中的所有元素都是可散列类型时，它才是可散列的。</li><li>如果一个对象是可散列的，那么在它的生命周期内散列值不变。与此同时，该对象还需要实现 <code>__hash__()</code> 方法，并且如果需要和其他的对象散列值相比，就必须再实现 <code>__eq__()</code> (参见 <b><a href="https://docs.python.org/3/glossary.html#term-hashable" target="_blank" rel="noopener"><code>hashable</code></a></b>)</li><li>自定义类型的对象默认都是可散列的, (参见 <b><a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a></b>)。如果一个对象实现了 <code>__eq__()</code> 方法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。没有实现 <code>__eq__()</code> 方法时，自定义对象是可散列的，否则之后在保持 <code>__eq__()</code> 使用的内部状态不可变，才可散列。</li></ul><p>eg.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">t1 = TestObject(<span class="number">1</span>)</span><br><span class="line">t2 = TestObject(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s.add(t1)</span><br><span class="line">s.add(t2)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p><p>这里的结果是 <code>{2, 1}</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self) == hash(obj)</span><br><span class="line"></span><br><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">t1 = TestObject(<span class="number">1</span>)</span><br><span class="line">t2 = TestObject(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s.add(t1)</span><br><span class="line">s.add(t2)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>我们只添加一个 <code>__eq__()</code> 的方法之后这段代码会报错，原因是在实现了 <code>__eq__()</code> 而没有实现<code>__hash__()</code> 的时候，默认 <code>__hash__()</code> 方法将设为 <code>None</code> 所以此时的错误为 <code>TypeError: unhashable type: &#39;TestObject&#39;</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self) == hash(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">t1 = TestObject(<span class="number">1</span>)</span><br><span class="line">t2 = TestObject(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s.add(t1)</span><br><span class="line">s.add(t2)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>而在实现了 <code>__hash__()</code> 方法之后，如果我们指定一个确定的值作为所有对象的 <code>hash</code> 的结果，这时候 <code>s</code> 就只有一个元素了，因为这个此时两个对象再进行比较的时候，通过 <code>__eq__()</code> 方法，但是此时两个对象的 <code>__hash__()</code> 都返回的是 <code>1</code> 因此就判定这两个对象是同一个，所以在 <code>set</code> 中只有一个了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self) == hash(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> id(self)</span><br><span class="line"></span><br><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">t1 = TestObject(<span class="number">1</span>)</span><br><span class="line">t2 = TestObject(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s.add(t1)</span><br><span class="line">s.add(t2)</span><br><span class="line">print(s)</span><br><span class="line">print(t1 <span class="keyword">is</span> t2)</span><br></pre></td></tr></table></figure><p><b>字典的定义</b></p><p>字典 <code>dict</code> 是一种映射类型的数据，我们可以用 <code>isinstance(obj, abc.Mapping)</code> 来判断任何一种对象是不是广义上的映射类型，这里的 <code>obj</code> 可以是内置的任何一种数据，当然也可是我们自己定义的任何一种数据。</p><p><b>构造一个字典</b></p><p>构造一个字典可以有很多种不同的形式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict(zip([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    (<span class="string">'a'</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">'b'</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">'c'</span>, <span class="number">3</span>)</span><br><span class="line">]</span><br><span class="line">d = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> data&#125;</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p><b><code>collections.defaultdict</code> 和 <code>collections.OrderedDict</code></b></p><p><code>collections</code> 是一个数据类型容器模块。<br>有关 <a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" target="_blank" rel="noopener"><code>defaultdict</code></a> 和 <a href="https://docs.python.org/3.7/library/collections.html#collections.OrderedDict" target="_blank" rel="noopener"><code>OrderedDict</code></a> 的介绍和草看使用可以参阅文档。</p><p><b><code>dict</code> <code>defaultdict</code> 和 <code>OrderedDict</code> 对比</b></p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">说明</th><th style="text-align:center">dict</th><th style="text-align:center">defaultdict</th><th style="text-align:center">OrderedDict</th></tr></thead><tbody><tr><td style="text-align:center"><code>d.__contains__(k)</code></td><td style="text-align:center"><code>k in d</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__copy__()</code></td><td style="text-align:center"><code>copy.copy(d)</code></td><td style="text-align:center">✗</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>d.__len__()</code></td><td style="text-align:center"><code>len(d)</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__setitem__(k, v)</code></td><td style="text-align:center"><code>d[k] = v</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__getitem__(k)</code></td><td style="text-align:center"><code>v = d[k]</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__delitem__(k)</code></td><td style="text-align:center"><code>del d[k]</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__iter__()</code></td><td style="text-align:center"><code>key</code>的迭代器</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.keys()</code></td><td style="text-align:center">获取所有<code>key</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.values()</code></td><td style="text-align:center">获取所有<code>value</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.copy()</code></td><td style="text-align:center">浅拷贝</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.clear()</code></td><td style="text-align:center">清空所有数据</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.update(m, [**kargs])</code></td><td style="text-align:center"><code>m</code> 是映射或者键值对迭代器，更新 <code>d</code> 里对应的条目</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.fromkeys(it, [initial])</code></td><td style="text-align:center">迭代器 <code>it</code> 里的元素设置为映射里的 <code>key</code>，可选 <code>initial</code> 参数，作为这些键对应的值(默认 <code>None</code>)</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.setdefault(k, [default])</code></td><td style="text-align:center">如果有键 <code>k</code>，把它的值设置为 <code>default</code> ，否则 <code>d[k] = default</code>，返回 <code>default</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.get(k, [default])</code></td><td style="text-align:center">返回 <code>k</code> 对应的值，如果没有 <code>k</code>，则返回 <code>default</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.pop(k, [defaul]</code></td><td style="text-align:center">返回 <code>k</code> 所应的值，弹出这个<code>k-v</code>。如果没有这个<code>k</code>，返回 <code>defaul</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.items()</code></td><td style="text-align:center">返回 <code>d</code> 里所有的 <code>k-v</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.popitem()</code></td><td style="text-align:center">随机弹出一个 <code>k-v</code> 对。会移除字典里最先插入的元素(FIFO)；可选 <code>last</code> 参数为<code>True</code>，弹出最后插入的元素(LIFO)。</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__missing__(k)</code></td><td style="text-align:center">当 <code>__getitem__</code> 找不到对应 <code>k</code> 的时候会被调用</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>d.default_factory</code></td><td style="text-align:center">在 <code>__missing__</code> 函数中用以给未找到的元素设置值</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>d.move_to_end(k, [last])</code></td><td style="text-align:center">把 <code>k</code> 的元素移动到最前或最后(<code>last</code> 默认 <code>True</code>)</td><td style="text-align:center">✗</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__reversed__()</code></td><td style="text-align:center">返回倒序的 <code>key</code> 的迭代器</td><td style="text-align:center">✗</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td></tr></tbody></table><p><b>集合 <code>set</code> </b></p><p><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/set-uml.png" alt></p><p>集合是许多唯一对象的聚合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'spam'</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'spam'</span>]</span><br><span class="line">s = set(l)</span><br><span class="line">print(list(s))</span><br></pre></td></tr></table></figure></p><p>集合中的元素必须是可散列的，<code>set</code> 类型本身是不可散列的，但是 <code>frozenset</code> 可以。所以可以创建一个包含不同 <code>frozenset</code> 的 <code>set</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;泛映射类型&lt;/b&gt; 抽象类：&lt;/p&gt;
&lt;p&gt;在 collections.abc 模块中有 &lt;b&gt;&lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#collections.abc.Mappin
      
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://www.zranbo.com/tags/Fluent-Python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 标签插件</title>
    <link href="https://www.zranbo.com/item/b32026b8/"/>
    <id>https://www.zranbo.com/item/b32026b8/</id>
    <published>2019-05-17T15:06:00.000Z</published>
    <updated>2019-05-18T04:27:59.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo内置"><a href="#Hexo内置" class="headerlink" title="Hexo内置"></a>Hexo内置</h1><p><b>引用块 (blockquote)</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><hr><p><b>Pull Quote</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><blockquote class="pullquote Wide Awake"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p></blockquote><h1 id="NexT-内置"><a href="#NexT-内置" class="headerlink" title="NexT 内置"></a>NexT 内置</h1><p><b>Bootstrap Callout</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] %&#125; Content &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>class为一下之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">primary</span><br><span class="line">success</span><br><span class="line">info</span><br><span class="line">warning</span><br><span class="line">danger</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><div class="note default"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note primary"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note success"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note info"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note warning"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note danger"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo内置&quot;&gt;&lt;a href=&quot;#Hexo内置&quot; class=&quot;headerlink&quot; title=&quot;Hexo内置&quot;&gt;&lt;/a&gt;Hexo内置&lt;/h1&gt;&lt;p&gt;&lt;b&gt;引用块 (blockquote)&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://www.zranbo.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python - 序列构成的数组 (二)</title>
    <link href="https://www.zranbo.com/item/2e88435f/"/>
    <id>https://www.zranbo.com/item/2e88435f/</id>
    <published>2019-05-15T09:01:00.000Z</published>
    <updated>2019-05-18T04:28:04.414Z</updated>
    
    <content type="html"><![CDATA[<p><b>序列类型概念</b></p><p>谈起序列，我们能说的就有很多了，比如我们很常用的<code>str</code> , <code>list</code> , <code>tuple</code> 等，Python用C语言实现了丰富的序列类型：</p><ul><li><p>容器序列（这些序列可以存放不同类型的数据）</p><p><code>list</code> <code>tuple</code> 等</p></li><li><p>扁平序列（这些序列只能存放同一种类型数据）</p><p><code>str</code> <code>bytes</code> <code>bytearray</code> <code>memoryview</code> <code>array.array</code> 等</p><p>这里需要注意一下点的是，对于容器序列，里面存放的是任意类型的对象的<b>引用</b>，而扁平序列是一串连续的内存空间，保存的是这些数据的值。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val = [<span class="number">1</span>]</span><br><span class="line">ctn = [val]</span><br><span class="line"></span><br><span class="line">print(ctn)</span><br><span class="line">val.append(<span class="number">2</span>)</span><br><span class="line">print(ctn)</span><br></pre></td></tr></table></figure><p><b>列表推导式</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"hello world"</span></span><br><span class="line">lst = [x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> string]</span><br></pre></td></tr></table></figure></p><p>这是一个很简单的列表推导式，当然，如果我们需要一些复杂的东西，可以这样变化一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'pink'</span>]</span><br><span class="line">sizes = [<span class="string">'M'</span>, <span class="string">'L'</span>, <span class="string">'XL'</span>]</span><br><span class="line"></span><br><span class="line">goods = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line">print(goods)</span><br><span class="line">goods = [(color, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes <span class="keyword">for</span> color <span class="keyword">in</span> colors]</span><br><span class="line">print(goods)</span><br></pre></td></tr></table></figure><p>调换了一下后面迭代的先后顺序，可以看到结果有了变化。</p><p><b>生成器表达式</b></p><p>从使用上来说，和列表推导式没有太大的区别，只是将<code>[ ]</code>换成<code>( )</code>。<br>列表推导式最终得到的是一个列表对象，而生成器表达式是一个元组对象。</p><p><b>元组不仅仅是不可变的列表</b></p><p>元组的一个特殊之处是对象一旦被创建，就不能更改，包括值和值所在的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">t2 = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">t3 = (<span class="string">'b'</span>, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">print(t1 <span class="keyword">is</span> t2)</span><br><span class="line">print(t1 <span class="keyword">is</span> t3)</span><br></pre></td></tr></table></figure><p>正因为这个，元组就变得有点意思了，因为除了具体的值，元组还可以比列表多记录一项内容：这些数据的位置也可以用来保存一定的信息。</p><p><b>序列的拆包</b></p><p>注意这里我们并没有用元组的拆包，那是因为并不是只有元组才能拆包，而是一般的，对于大多数Python的序列，我们都可以这要去做<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eg = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">ele1, ele2, ele3 = eg</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">egl = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">ele1, ele2, ele3 = egl</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">eg2 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">ele1, ele2, ele3 = eg2</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">eg3 = <span class="string">'abc'</span></span><br><span class="line">ele1, ele2, ele3 = eg3</span><br><span class="line">print(ele1, ele2, ele3)</span><br></pre></td></tr></table></figure></p><p>值得注意的一点是，对于字典 <code>dict</code> 的拆包，并不是把 <code>key-value</code> 这个键值对拿出来了，而只是把 <code>key</code> 拆开了，其实对于这个我们一点也不惊讶，毕竟如果我们需要对字典的 <code>key-value</code> 都进行迭代，并不是 <code>for data in dict</code> 而是 <code>for k, v in dict.items()</code> 注意观察到其实我们也发现了，这里不就是用了对字典的 <code>key-value</code> 拆包的方法么？</p><p><b>序列拆包中 <code>*</code> 的作用</b></p><p>对于拆包过程中，我们可以使用 <code>*</code> 来包含多个元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>)</span><br><span class="line">ele1, ele2, *eles = t</span><br><span class="line">print(ele1, ele2, eles)</span><br></pre></td></tr></table></figure></p><p>而 <code>*</code> 表示的多个元素则会放到一个列表中去。</p><p>而且这个 <code>*</code> 可以放到中间表示出了首末若干元素的其他所有元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>)</span><br><span class="line">ele1, ele2, *eles, ele3 = t</span><br><span class="line">print(ele1, ele2, eles, ele3)</span><br></pre></td></tr></table></figure></p><p><b>元组和列表的区别</b></p><p>这里的区别体现在一些内置的属性方法上。列表说明</p><table><thead><tr><th style="text-align:center">属性方法</th><th style="text-align:center">说明</th><th style="text-align:center">列表</th><th style="text-align:center">元组</th></tr></thead><tbody><tr><td style="text-align:center"><code>s.__getnewargs__()</code></td><td style="text-align:center"><code>pickle</code> 中支持更加优化的序列化</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__add__(s2)</code></td><td style="text-align:center"><code>s + s2</code>，拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__contains__(e)</code></td><td style="text-align:center"><code>s</code> 是否包含 <code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.index(e)</code></td><td style="text-align:center">在 <code>s</code> 中找到元素 <code>e</code> 第一次出现的位置</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.count(e)</code></td><td style="text-align:center"><code>e</code> 在 <code>s</code> 中出现的次数</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__getitem__(p)</code></td><td style="text-align:center"><code>s[p]</code>，获取位置 <code>p</code> 的元素</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__iter__()</code></td><td style="text-align:center">获取 <code>s</code> 的迭代器</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__len__()</code></td><td style="text-align:center"><code>len(s)</code>，元素的数量</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__mul__(n)</code></td><td style="text-align:center"><code>s * n</code>，<code>n</code> 个 <code>s</code> 的重复拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__rmul__(n)</code></td><td style="text-align:center"><code>n * s</code>，反向拼接 *</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__delitem__(p)</code></td><td style="text-align:center">把位于 <code>p</code> 的元素删除</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__reversed__()</code></td><td style="text-align:center">返回 <code>s</code> 的倒序迭代器</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__setitem__(p, e)</code></td><td style="text-align:center"><code>s[p] = e</code>，把元素 <code>e</code> 放在位置 <code>p</code>，替代已经在那个位置的元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__imul__(n)</code></td><td style="text-align:center"><code>s *= n</code>，就地重复拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__iadd__(s2)</code></td><td style="text-align:center"><code>s += s2</code>，就地拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.insert(p, e)</code></td><td style="text-align:center">在位置 <code>p</code> 之前插入元素<code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.append(e)</code></td><td style="text-align:center">在尾部添加一个新元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.clear()</code></td><td style="text-align:center">删除所有元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.copy()</code></td><td style="text-align:center">浅复制</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.extend(it)</code></td><td style="text-align:center">把可迭代对象 <code>it</code> 追加给 <code>s</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.pop([p])</code></td><td style="text-align:center">删除最后或者是（可选的）位于 <code>p</code> 的元素，并返回它的值</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.remove(e)</code></td><td style="text-align:center">删除 <code>s</code> 中的第一次出现的 <code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.reverse()</code></td><td style="text-align:center">就地倒序</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.sort([key], [reverse])</code></td><td style="text-align:center">就地对 <code>s</code> 中的元素进行排序，可选的参数有键（<code>key</code>）和是否倒序（<code>reverse</code>）</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;序列类型概念&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;谈起序列，我们能说的就有很多了，比如我们很常用的&lt;code&gt;str&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;tuple&lt;/code&gt; 等，Python用C语言实现了丰富的序列类型：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://www.zranbo.com/tags/Fluent-Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python - Python数据模型 (一)</title>
    <link href="https://www.zranbo.com/item/1bbbb445/"/>
    <id>https://www.zranbo.com/item/1bbbb445/</id>
    <published>2019-05-14T06:03:00.000Z</published>
    <updated>2019-05-17T14:59:19.076Z</updated>
    
    <content type="html"><![CDATA[<p><b>Magic Method (Dunder Method)</b></p><div class="note info"><p>Python 里面有很多特殊方法，我们管他叫魔术方法(magic method)。之所以特殊，是因为这些方法不同于一般的对象方法的调用方式 <code>Object.function</code>，比如对于获取字符串对象 <code>s = &quot;Hello&quot;</code> 的长度,不同于其他一些语言的 <code>s.length()</code> 或者类似的方法，Python采用 <code>len(s)</code> 这样的形式。 </p></div><blockquote><p>首先明确一点，特殊方法的存在是为了被 Python 解释器调用的，你自己并不需要调用它们。也就是说没有 <code>my_object.__len__()</code> 这种写法，而应该使用 <code>len(my_object</code>)。在执行 <code>len(my_object)</code> 的时候，如果 <code>my_object</code> 是一个自定义类的对象，那么 Python 会自己去调用其中由你实现的 <code>__len__</code> 方法。</p><footer><strong>——Fluent Python</strong></footer></blockquote><p>而 Python 里面这样的特殊方法还有很多，列一个表格说明一些。</p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:center">字符串/字节序列表示形式</td><td style="text-align:left"><code>__repr__</code>、<code>__str__</code>、<code>__format__</code>、<code>__bytes__</code></td></tr><tr><td style="text-align:center">数值转换</td><td style="text-align:left"><code>__abs__</code>、<code>__bool__</code>、<code>__complex__</code>、<code>__int__</code>、<code>__float__</code>、<code>__hash__</code>、<code>__index__</code></td></tr><tr><td style="text-align:center">集合模拟</td><td style="text-align:left"><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td></tr><tr><td style="text-align:center">迭代枚举</td><td style="text-align:left"><code>__iter__</code>、<code>__reversed__</code>、<code>__next__</code></td></tr><tr><td style="text-align:center">可调用模拟</td><td style="text-align:left"><code>__call__</code></td></tr><tr><td style="text-align:center">上下文管理</td><td style="text-align:left"><code>__enter__</code>、<code>__exit__</code></td></tr><tr><td style="text-align:center">实例创建和销毁</td><td style="text-align:left"><code>__new__</code>、<code>__init__</code>、<code>__del__</code></td></tr><tr><td style="text-align:center">属性管理</td><td style="text-align:left"><code>__getattr__</code>、<code>__getattribute__</code>、<code>__setattr__</code>、<code>__delattr__</code>、<code>__dir__</code></td></tr><tr><td style="text-align:center">属性描述符</td><td style="text-align:left"><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td></tr><tr><td style="text-align:center">类相关服务</td><td style="text-align:left"><code>__prepare__</code>、<code>__instancecheck__</code>、<code>__subclasscheck__</code></td></tr></tbody></table><p>上面表格里面列举的并不是所有的，还有很多比如与运算相关的特殊方法 <code>__add__</code> 、 <code>__abs__</code> 等都没有列举。</p><p><b>一些常用操作对应的魔术方法</b></p><ul><li><p><code>for</code> 迭代操作</p><p>如果一个对象可以通过 <code>for</code> 循环，需要实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法，并且需要在 <code>__next__()</code> 中通过抛出 <code>StopIteration</code> 异常来控制 <code>for</code> 的终止行为:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init=<span class="number">0</span>, stop=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.init = init</span><br><span class="line">        self.data = init</span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.data &gt;= self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data</span><br><span class="line">            </span><br><span class="line">obj = tObject()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><ul><li><p><code>in</code> 操作</p><p>用 <code>in</code> 判断对象关系的时候，需要实现 <code>__contains__()</code>，但是如果没有实现 <code>__contains__()</code> ，会进行一次迭代操作：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init=<span class="number">0</span>, stop=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.init = init</span><br><span class="line">        self.data = init</span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.data &gt;= self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.init &lt; key &lt; self.stop:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">obj = tObject()</span><br><span class="line"></span><br><span class="line">print(<span class="number">5</span> <span class="keyword">in</span> obj)</span><br></pre></td></tr></table></figure><p>但是如果没有实现 <code>__contains__()</code> 这里这里就会首先进行一次迭代操作，然后去判断。</p><ul><li><p><code>print()</code>或<code>str()</code></p><p><code>__repr__()</code>的目的应该是能准确表达出对象。</p><p><code>__str__()</code>的目的是能友好的可读的表达对象。</p></li></ul><ul><li><p><code>[]</code> 取值&amp;赋值&amp;操作</p><p>分别是 <code>__getitem__()</code> 和 <code>__setitem__()</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data.get(key, <span class="string">'N/A'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        self.data[key] = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = tObject()</span><br><span class="line">obj[<span class="string">'1'</span>] = <span class="string">'a'</span></span><br><span class="line">print(obj[<span class="string">'1'</span>])</span><br></pre></td></tr></table></figure><p><code>__getitem__()</code> 方法用于返回参数 <code>key</code> 所对应的值，这个 <code>key</code> 可以是索引，关键字或切片对象，并且支持负数索引；如果 <code>key</code> 不是以上两种类型，就会抛出 <code>TypeError</code> ；如果索引越界，会抛 <code>IndexError</code> ；如果定义的是映射类型，当 <code>key</code> 参数不是其对象的键值时，则会抛出 <code>KeyError</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;Magic Method (Dunder Method)&lt;/b&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Python 里面有很多特殊方法，我们管他叫魔术方法(magic method)。之所以特殊，是因为这些方法不同于一般的对象方法的调用方式 &lt;
      
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://www.zranbo.com/tags/Fluent-Python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.zranbo.com/item/4a17b156/"/>
    <id>https://www.zranbo.com/item/4a17b156/</id>
    <published>2019-05-05T09:52:00.000Z</published>
    <updated>2019-05-17T14:48:52.293Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Void" scheme="https://www.zranbo.com/tags/Void/"/>
    
  </entry>
  
</feed>
