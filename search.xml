<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker从入门到再入门 - Hello World (二)</title>
      <link href="/item/83fde42c/"/>
      <url>/item/83fde42c/</url>
      
        <content type="html"><![CDATA[<p><strong> Hello World </strong></p><p>通过一个简单的 <code>hello world</code> 的例子体验一下 Docker 的使用</p><p><code>docker search</code> 可以找到我们想要的镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> $ docker search hello-world</span><br><span class="line">NAME                                       DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">hello-world                                Hello World! (an example of minimal Dockeriz…   936                 [OK]                </span><br><span class="line">kitematic/hello-world-nginx                A light-weight nginx container that demonstr…   124                                     </span><br><span class="line">tutum/hello-world                          Image to <span class="built_in">test</span> docker deployments. Has Apache…   60                                      [OK]</span><br><span class="line">dockercloud/hello-world                    Hello World!                                    15                                      [OK]</span><br><span class="line">crccheck/hello-world                       Hello World web server <span class="keyword">in</span> under 2.5 MB          7                                       [OK]</span><br><span class="line">ppc64le/hello-world                        Hello World! (an example of minimal Dockeriz…   2                                       </span><br><span class="line">souravpatnaik/hello-world-go               hello-world <span class="keyword">in</span> Golang                           1                                       </span><br><span class="line">carinamarina/hello-world-app               This is a sample Python web application, run…   1                                       [OK]</span><br><span class="line">markmnei/hello-world-java-docker           Hello-World-Java-docker                         1                                       [OK]</span><br><span class="line">ansibleplaybookbundle/hello-world-db-apb   An APB <span class="built_in">which</span> deploys a sample Hello World! a…   0                                       [OK]</span><br><span class="line">koudaiii/hello-world                                                                       0                                       </span><br><span class="line">kevindockercompany/hello-world                                                             0                                       </span><br><span class="line">ansibleplaybookbundle/hello-world-apb      An APB <span class="built_in">which</span> deploys a sample Hello World! a…   0                                       [OK]</span><br><span class="line">burdz/hello-world-k8s                      To provide a simple webserver that can have …   0                                       [OK]</span><br><span class="line">uniplaces/hello-world                                                                      0                                       </span><br><span class="line">ansibleplaybookbundle/hello-world          Simple containerized application that tests …   0                                       </span><br><span class="line">nirmata/hello-world                                                                        0                                       [OK]</span><br><span class="line">infrastructureascode/hello-world           A tiny <span class="string">"Hello World"</span> web server with a healt…   0                                       [OK]</span><br><span class="line">stumacsolutions/hello-world-container                                                      0                                       </span><br><span class="line">mbrainar/hello-world                       Python-based hello-world web service            0                                       </span><br><span class="line">sharor/hello-world                                                                         0                                       </span><br><span class="line">s390x/hello-world                          Hello World! (an example of minimal Dockeriz…   0                                       </span><br><span class="line">kousik93/hello-world                                                                       0                                       </span><br><span class="line">ebenjaminv9/hello-world                    Hello-world                                     0                                       </span><br><span class="line">jensendw/hello-world                                                                       0</span><br></pre></td></tr></table></figure></p><p>通过 <code>docker pull</code>命令可以把我们想要的镜像下载下来。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull hello-world</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete </span><br><span class="line">Digest: sha256:0e11c388b664df8a27a901dce21eb89f11d8292f7fca1b3e3c4321bf7897bffe</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br></pre></td></tr></table></figure></p><p><code>docker images</code> 可以查看我们下载下来的所有镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        4 months ago        1.84kB</span><br></pre></td></tr></table></figure></p><ul><li><code>REPOSITORY</code> 是镜像的名称</li><li><code>TAG</code> 镜像的标签，可以理解为镜像的版本</li><li><code>IMAGE ID</code> 镜像的ID 一般唯一表示一个镜像可只使用前6位</li><li><code>CREATED</code> 镜像的最后一次构建时间</li><li><code>SIZE</code> 镜像的大小</li></ul><p>从上一篇中我们知道，镜像(Image)和容器(Container)的关系就好像类和实例一样，因此如果想运行这个镜像，就必须先‘实例化’一下这个镜像。而这个‘实例’的过程就是 <code>docker run</code> 命令来完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>我们需要注意的是，<code>docker run</code> 命令如果是一个本地不存在的镜像首先会尝试下载，然后运行容器。</p><p><code>hello-world</code> 镜像再运行后会输出以上内容，输出以后容器自动停止，停止的容器并不会被删除。我们可以用 <code>docker ps -a</code> 命令查看所有的容器。</p><p>注意：查看容器的命令 <code>docker ps</code> 但此时只能查看当前正在运行的容器，而想要查看所有容器(包含未运行)就需要 <code>-a</code> 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">814d3d9a317b        hello-world         <span class="string">"/hello"</span>            3 minutes ago       Exited (0) 3 minutes ago                       boring_ishizaka</span><br></pre></td></tr></table></figure><p>当我们不需要一个容器的时候，可以删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm 4619207cb6a3</span><br><span class="line">4619207cb6a3</span><br></pre></td></tr></table></figure><p>删除一个容器用到的 <code>rm</code> 后面不一定必须跟 <code>CONTAINER ID</code>，而是只要能唯一表示一个容器的就可以，所以因为可以使用 <code>NAMES</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS                          PORTS               NAMES</span><br><span class="line">c1b20afd08bb        hello-world         <span class="string">"/hello"</span>            About a minute ago   Exited (0) About a minute ago                       condescending_hopper</span><br><span class="line">$ docker rm condescending_hopper</span><br><span class="line">condescending_hopper</span><br></pre></td></tr></table></figure><p>相同的一个镜像也可以删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        4 months ago        1.84kB</span><br><span class="line">$ docker rmi fce289e99eb9</span><br></pre></td></tr></table></figure><p>和删除容器类似，<code>rmi</code> 后面不一定是 <code>IMAGE ID</code> 只要是能唯一表示一个镜像的名称就可以，所以用<code>REPOSITORY</code>也可以。</p><p>但是删除容器需要注意，容器不能是在运行中，删除镜像要求不能有这个镜像的容器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker从入门到再入门 - 初识 (一)</title>
      <link href="/item/f79e33ca/"/>
      <url>/item/f79e33ca/</url>
      
        <content type="html"><![CDATA[<p><b>什么是Docker?</b></p><p><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/docker_intr.jpg" alt></p><p>以上图片摘自 <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a> </p><p><code>Docker</code> 是一个基于 <code>Go</code> 语言的开源容器引擎。<code>Docker</code> 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器上，也可以实现虚拟化。并且容器的使用开销极低，启动速度也非常快。</p><p><b>安装 Docker</b></p><p><code>Docker</code> 有两个版本：社区版(Community Edition，缩写 CE)和企业版（Enterprise Edition，缩写 EE）一般个人安装 CE 版本</p><p>Docker CE 的安装参考官方文档：</p><ul><li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Ubuntu</a></li><li><a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">Mac</a></li><li><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Windows</a></li></ul><p>安装完成后，可以通过 <code>docker --version</code> 验证版本</p><div class="note danger"><p>Linux 安装完成后如果是非 <code>root</code> 用户输入 <code>docker</code> 会提示出错: <code>permission denied</code><br>解决办法是将当前用户加入 <code>docker</code> 用户组<br><code>sudo usermod -a -G docker $USER</code> 并重新启动系统<br>利用 <code>groups</code> 查看 <code>docker</code> 是否在其中</p></div><p><b>几个概念</b></p><ol><li><h6 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像 (Image)"></a>镜像 (<code>Image</code>)</h6><p>首先操作系统分为内核和用户空间。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支 持。而 <code>Docker</code> 镜像（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 <code>Ubuntu 18.04</code> 最小系统的 <code>root</code> 文件系统。</p><p><code>Docker</code> 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></li><li><h6 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器 (Container)"></a>容器 (<code>Container</code>)</h6><p>镜像 (<code>Image</code>) 和容器 (<code>Container</code>) 的关系，就像是面向对象程序设计中的类(<code>class</code>)和实例(<code>Instance</code>) 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 <code>ID</code> 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 <code>Docker</code> 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷 (<code>Volume</code>)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储) 发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p></li><li><h6 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(<code>Repository</code>)</h6><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> 就是这样的服务。</p><p>一个 <code>Docker Registry</code> 中可以包含多个<strong>仓库（<code>Repository</code>）</strong>；每个仓库可以包含多个<strong>标签（<code>Tag</code>）</strong>；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <code>Ubuntu</code> 镜像 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <strong>两段式路径</strong> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 <code>Docker Registry</code> 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 <code>Docker Registry</code> 的软件或服务。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-gitalk-Pushover 实现消息推送</title>
      <link href="/item/609f08f9/"/>
      <url>/item/609f08f9/</url>
      
        <content type="html"><![CDATA[<p><b>前言</b></p><p>用Hexo搭建了这个博客，并且找到了一个利用 GitHub Issue 实现评论功能的插件 gitalk</p><div style="text-align:center">  <div class="github-card" data-user="gitalk" data-repo="gitalk" data-width="100%" data-theme="default" data-target="blank" data-client-id data-client-secret></div></div><script src="/github-card-lib/githubcard.js"></script><p>从而实现了网站的评论功能。但网站的评论不同于微信等即时通讯的消息，别人的评论有可能你没法马上看到。所以有个想法：怎么样能在别人评论完之后我马上就能知道呢？</p><p>考虑到消息推送的时效，想到了 iPhone 的消息推送。这样每当有评论留言可以很快地收到一个消息提醒自己。但 iPhone 的消息推送还是很复杂的，首先要有一个上架 AppStore 的应用。但幸好已经有了这样的应用，这里我就用了 <a href="https://itunes.apple.com/cn/app/pushover-notifications/id506088175" target="_blank" rel="noopener">Pushover</a> 替我进行消息的推送。</p><p><b>配置Pushover</b></p><p>AppStore 上的 Pushover 是付费应用，价格 ¥30.00</p><p>购买后可以申请一个账户，然后注册该设备，之后你会得到一个<code>User Key</code><br><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/pushover_key_demo.jpg" alt></p><p>然后从浏览器进入 Pushover 界面 <a href="https://pushover.net" target="_blank">https://pushover.net</a> 从右上角登录刚刚注册的账户</p><p>如果之前的都已经做了，那么在 Your Devices 部分应该可以看到你刚刚的设备了。</p><p>在底下 Your Applications 创建一个应用<br><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/pushover_application.jpg" alt></p><p>填写好这些信息后，你会获得一个 <code>API Token</code> 至此有关 Pushover 的配置就完成了，有了上面的 <code>User Key</code> 和刚刚拿到的 <code>API Token</code> 我们就能自定义的给刚刚注册的手机发送推送通知了。</p><p><b>Push Demo</b></p><p>首先我们先试一下这个消息推送</p><p>消息推送采用的是 Restapi 风格的接口。地址是 <a href="https://api.pushover.net/1/messages.json" target="_blank">https://api.pushover.net/1/messages.json</a></p><p>具体的接口文档参阅 <a href="https://pushover.net/api" target="_blank" rel="noopener">Pushover Message API</a></p><p>如何做到评论之后马上就能推送消息呢？这里我们用 GitHub 的 Webhook ，当有新的评论的时候，就触发这个 Webhook 。我们要做的就只需要找一台拥有公网 ip 的服务器主机，搭建一个简单的 Web 服务。</p><p>tool.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PushOver</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token, user)</span>:</span></span><br><span class="line">        self.api = <span class="string">"https://api.pushover.net/1/messages.json"</span></span><br><span class="line"></span><br><span class="line">        self.rdata = &#123;</span><br><span class="line">            <span class="string">"token"</span>: token,</span><br><span class="line">            <span class="string">"user"</span>: user,</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loads</span><span class="params">(self, dictdata)</span>:</span></span><br><span class="line">        title = dictdata[<span class="string">'issue'</span>][<span class="string">'title'</span>]</span><br><span class="line">        user = dictdata[<span class="string">'comment'</span>][<span class="string">'user'</span>][<span class="string">'login'</span>]</span><br><span class="line">        comment = dictdata[<span class="string">'comment'</span>][<span class="string">'body'</span>]</span><br><span class="line">        url = dictdata[<span class="string">'issue'</span>][<span class="string">'body'</span>].split(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        msg = <span class="string">"&#123;t&#125;\n&#123;u&#125;:&#123;c&#125;"</span>.format(t=title, u=user, c=comment)</span><br><span class="line"></span><br><span class="line">        self.rdata[<span class="string">'message'</span>] = msg</span><br><span class="line">        self.rdata[<span class="string">'url'</span>] = url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># print(self.rdata)</span></span><br><span class="line">            requests.post(self.api, data=self.rdata)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line">pushover = PushOver([:API Token], [:User Key])</span><br></pre></td></tr></table></figure></p><p>pushover.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, redirect, request</span><br><span class="line"><span class="keyword">from</span> tool <span class="keyword">import</span> pushover</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/webhook', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">webhook</span><span class="params">()</span>:</span></span><br><span class="line">    req = json.loads(request.data)</span><br><span class="line">    action = req[<span class="string">'action'</span>]</span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">'created'</span>:</span><br><span class="line">        pushover.loads(req)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pushover.send()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'OK'</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'ERROR'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'PASS'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure></p><p>将这两个脚本放到服务器上，安装 gunicorn 启动脚本运行 Web 服务</p><p><code>gunicorn -w 4 -b 0.0.0.0:80 webhook:app</code></p><p><b>配置 Webhook</b></p><p>打开 gitalk 配置的评论仓库，在 Webhooks 设置中添加一个 webhook</p><p><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/webhook_demo.jpg" alt></p><p>Payload URL 中填写 <code>http://ip:port/webhook</code> 如果你的服务器提供商允许使用 <code>80</code> 端口可以不写 <code>:80</code><br>保存之后就可以试一下评论看有没有消息推送。</p><p><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/pushover_msg_demo.jpg" alt></p><p>如果没有，可以在 Github Webhook 页面看到调用 wenhook 的记录，排查错误。<br><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/webhook_recent.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux/Unix进程管理工具 - Supervisor</title>
      <link href="/item/1f6c73c0/"/>
      <url>/item/1f6c73c0/</url>
      
        <content type="html"><![CDATA[<p><b>Supervisor</b></p><p><a href="http://supervisord.org/" target="_blank" rel="noopener"><code>Supervisor</code></a> 是一个用 <code>Python2</code> 实现的 Unix-like 系统进程管理工具。</p><p><b>安装</b></p><ol><li>Ubuntu : <code>apt install supervisor</code></li><li>其他 Linux 发行版: <code>pip install supervisor</code> (只支持 <code>Python2</code> 因此请确定是<code>Python2</code>的<code>pip</code>)</li></ol><p>安装完成后会生成三个执行程序：<code>supervisortd</code> <code>supervisorctl</code> <code>echo_supervisord_conf</code> 分别是：守护进程服务、客户端、初始配置文件程序。</p><p><b>配置</b></p><p>运行 <code>supervisord</code> 要指定 <code>supervisor</code> 配置文件,默认在以下目录查找：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure></p><p>并且可以通过 <code>echo_supervisord_conf</code> 生成一份 <code>supervisor</code> 配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure></p><p><b>主程序配置文件说明</b></p><p>注释：以分号 <code>;</code> 开头的表示注释行<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/tmp/supervisor.sock; UNIX socket 文件，supervisorctl要用</span><br><span class="line"><span class="comment">;chmod=0700; socket文件的权限，默认是0700</span></span><br><span class="line"><span class="comment">;chown=nobody:nogroup; socket文件的 owner，格式：uid:gid</span></span><br><span class="line"><span class="comment">;username=user; 登录管理后台的用户名</span></span><br><span class="line"><span class="comment">;password=123; 登录管理后台的密码</span></span><br><span class="line"></span><br><span class="line"><span class="section">[inet_http_server]</span><span class="comment">; HTTP服务，提供Web端管理界面</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span>; Web管理后台运行的IP和端口</span><br><span class="line"><span class="attr">username</span>=user; 登录管理后台的用户名</span><br><span class="line"><span class="attr">password</span>=<span class="number">123</span>; 登录管理后台的密码</span><br><span class="line"></span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/supervisord.log ; 主程序的日志文件</span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        ; 主程序日志大小，默认 <span class="number">50</span>MB，<span class="number">0</span>，表示不限制</span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           ; 主程序日志备份数量，默认<span class="number">10</span>，<span class="number">0</span>，表示不备份</span><br><span class="line"><span class="attr">loglevel</span>=info                ; 主程序日志级别，默认 info，其它: debug,warn,trace</span><br><span class="line"><span class="attr">pidfile</span>=/tmp/supervisord.pid ; supervisord pid 文件; 默认 supervisord.pid</span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               ; 是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                  ; 可以打开的文件描述符的最小值，默认 <span class="number">1024</span></span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>                 ; 可以打开的进程数的最小值，默认 <span class="number">200</span></span><br><span class="line"><span class="comment">;umask=022                   ; umask 022 创建新文件权限为755</span></span><br><span class="line"><span class="comment">;user=chrism                 ; 启动用户，默认为当前用户</span></span><br><span class="line"><span class="comment">;identifier=supervisor       ; supervisord 标识, 默认 `supervisor`</span></span><br><span class="line"><span class="comment">;directory=/tmp              ; 当 supervisord 守护进程时，切换到此目录</span></span><br><span class="line"><span class="comment">;nocleanup=true              ; 启动时清除子日志文件，默认 false</span></span><br><span class="line"><span class="comment">;childlogdir=/tmp            ; 子日志文件路径 默认为 $TEMP</span></span><br><span class="line"><span class="comment">;environment=KEY="value"     ; 添加环境变量到 supervisord 进程的环境中</span></span><br><span class="line"><span class="comment">;strip_ansi=false            ; 删除日志文件中所有ANSI转义序列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[rpcinterface:supervisor]</span></span><br><span class="line"><span class="attr">supervisor.rpcinterface_factory</span> = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///tmp/supervisor.sock; 通过UNIX socket 连接supervisord，与[unix_http_server]部分file一致</span><br><span class="line"><span class="comment">;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 方式连接 supervisord</span></span><br><span class="line"><span class="comment">;username=chris              ; 用于身份验证的用户名。与 supervisord 服务器配置的用户名相同</span></span><br><span class="line"><span class="comment">;password=123                ; 用于身份验证的密码。与 supervisord 服务器配置的密码的明文相同。</span></span><br><span class="line"><span class="comment">;prompt=mysupervisor         ; 用作 supervisorctl 提示符的字符串</span></span><br><span class="line"><span class="comment">;history_file=~/.sc_history  ; 用作 readline 持久性历史记录文件的路径</span></span><br><span class="line"></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/conf.d/*.ini ; 可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure></p><p><b>配置管理进程</b></p><p>进程管理配置参数，不建议全都写在 <code>supervisord.conf</code> 文件中，建议每个进程采用一个配置文件放到 <code>supervisord.conf</code> 配置中 <code>[include]</code>字段 <code>files</code> 指定的路径下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;[program:programname]; program:xxx (xxx 为自定义的管理的进程的名称名称，不可重复)</span></span><br><span class="line"><span class="comment">;command=/bin/cat; 程序启动命令 (该命令只能是前台任务命令)</span></span><br><span class="line"><span class="comment">;process_name=%(program_name)s; 进程名称</span></span><br><span class="line"><span class="comment">;numprocs=1; 进程数量 (默认为 1)</span></span><br><span class="line"><span class="comment">;directory=/tmp               ; 在执行 command 之前，supervisord 切换到的目录。</span></span><br><span class="line"><span class="comment">;autostart=true                ; supervisord 启动的时候也自动启动</span></span><br><span class="line"><span class="comment">;startsecs=1                   ; 启动1秒后没有异常退出，就表示进程正常启动了，默认为1秒</span></span><br><span class="line"><span class="comment">;startretries=3                ; 启动失败自动重试次数，默认是3次</span></span><br><span class="line"><span class="comment">;autorestart=unexpected        ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span></span><br><span class="line"><span class="comment">;stopasgroup=false             ; 进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span></span><br><span class="line"><span class="comment">;killasgroup=false             ; 进程组发送kill信号，包括子进程</span></span><br><span class="line"><span class="comment">;user=chrism                   ; 启动进程的用户</span></span><br><span class="line"><span class="comment">;redirect_stderr=false          ; 把stderr重定向到stdout，默认false</span></span><br><span class="line"><span class="comment">;stdout_logfile=/a/path        ; stdout 日志文件路径</span></span><br><span class="line"><span class="comment">;stdout_logfile_maxbytes=1MB   ; stdout 日志文件大小 0 表示无限制</span></span><br><span class="line"><span class="comment">;stdout_logfile_backups=10     ; stdout 日志文件备份数量 0 表示不备份</span></span><br><span class="line"><span class="comment">;stdout_capture_maxbytes=1MB   ; stdout 捕获模式 日志文件大小</span></span><br><span class="line"><span class="comment">;stderr_logfile=/a/path        ; stderr 日志文件路径</span></span><br><span class="line"><span class="comment">;stderr_logfile_maxbytes=1MB   ; stderr 日志文件大小 0 表示无限制</span></span><br><span class="line"><span class="comment">;stderr_logfile_backups=10     ; stderr 日志文件备份数量 0 表示不备份</span></span><br><span class="line"><span class="comment">;stderr_capture_maxbytes=1MB   ; stderr 捕获模式 日志文件大小</span></span><br><span class="line"><span class="comment">;environment=A="1",B="2"       ; 添加环境变量到子进程的环境中</span></span><br></pre></td></tr></table></figure><p><b>启动Supervisor服务</b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure><p><b>supervisorctl 管理进程</b></p><p>启动成功后，就可以通过 supervisorctl 管理进程。在 shell 中直接输入 <code>supervisorctl</code> 就可以直接进入交互式的环境中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> status<span class="comment"># 查看所有进程的状态</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> update<span class="comment"># 重启配置文件修改过的程序</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> reread<span class="comment"># 读取有更新（增加）的配置文件，不会启动新添加的程序</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> start program<span class="comment"># 启动 program 程序</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> stop program<span class="comment"># 停止 program 程序</span></span></span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"> restart program<span class="comment"># 重启 program 程序</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的Python - 文本和字节序列 (四)</title>
      <link href="/item/d12c295b/"/>
      <url>/item/d12c295b/</url>
      
        <content type="html"><![CDATA[<p><b>字符问题</b></p><p>字符串本身是个字符序列。这个定义没有问题。但是问题出现在对于“字符”的定义上。对于现在来说，“字符”应该是一个 Unicode 字符。</p><p>Unicode 标准把字符的标识和具体的字节表述进行了如下的明确区分</p><ul><li>字符的标识，即码位，是 0~1 114 111 的数字（十进制），在 Unicode 标准中以 4~6 个 十六进制数字表示，而且加前缀“U+”。例如，字母 A 的码位是 U+0041，欧元符号的 码位是 U+20AC，高音谱号的码位是 U+1D11E。在 Unicode 6.3 中（这是 Python 3.4 使 用的标准），约 10% 的有效码位有对应的字符。</li><li>字符的具体表述取决于所用的编码。编码是在码位和字节序列之间转换时使用的算法。 在 UTF-8 编码中，A（U+0041）的码位编码成单个字节 \x41，而在 UTF-16LE 编码中 编码成两个字节 \x41\x00。再举个例子，欧元符号（U+20AC）在 UTF-8 编码中是三个 字节——\xe2\x82\xac，而在 UTF-16LE 中编码成两个字节 \xac\x20。</li></ul><p>把码位转换成字节序列的过程是编码；把字节序列转换成码位的过程是解码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"你好hello"</span></span><br><span class="line">print(s, len(s))</span><br><span class="line">b = s.encode(<span class="string">'utf8'</span>)</span><br><span class="line">print(b, len(b))</span><br><span class="line">print(b.decode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的Python - 字典和集合 (三)</title>
      <link href="/item/3dd06891/"/>
      <url>/item/3dd06891/</url>
      
        <content type="html"><![CDATA[<p><b>泛映射类型</b> 抽象类：</p><p>在 collections.abc 模块中有 <b><a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mpping</code></a></b> 和 <b><a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>MutableMapping</code></a></b> 为 <code>dict</code> 和其他一些类提供了最基本的接口<br><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/dict-uml.png" alt></p><p><b>可散列类型</b></p><ul><li><code>str</code> <code>bytes</code> <code>frozenset</code>只能容纳可散列对象，<code>tuple</code> 只有当其中的所有元素都是可散列类型时，它才是可散列的。</li><li>如果一个对象是可散列的，那么在它的生命周期内散列值不变。与此同时，该对象还需要实现 <code>__hash__()</code> 方法，并且如果需要和其他的对象散列值相比，就必须再实现 <code>__eq__()</code> (参见 <b><a href="https://docs.python.org/3/glossary.html#term-hashable" target="_blank" rel="noopener"><code>hashable</code></a></b>)</li><li>自定义类型的对象默认都是可散列的, (参见 <b><a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a></b>)。如果一个对象实现了 <code>__eq__()</code> 方法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。没有实现 <code>__eq__()</code> 方法时，自定义对象是可散列的，否则之后在保持 <code>__eq__()</code> 使用的内部状态不可变，才可散列。</li></ul><p>eg.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">t1 = TestObject(<span class="number">1</span>)</span><br><span class="line">t2 = TestObject(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s.add(t1)</span><br><span class="line">s.add(t2)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p><p>这里的结果是 <code>{2, 1}</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self) == hash(obj)</span><br><span class="line"></span><br><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">t1 = TestObject(<span class="number">1</span>)</span><br><span class="line">t2 = TestObject(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s.add(t1)</span><br><span class="line">s.add(t2)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>我们只添加一个 <code>__eq__()</code> 的方法之后这段代码会报错，原因是在实现了 <code>__eq__()</code> 而没有实现<code>__hash__()</code> 的时候，默认 <code>__hash__()</code> 方法将设为 <code>None</code> 所以此时的错误为 <code>TypeError: unhashable type: &#39;TestObject&#39;</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self) == hash(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">t1 = TestObject(<span class="number">1</span>)</span><br><span class="line">t2 = TestObject(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s.add(t1)</span><br><span class="line">s.add(t2)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>而在实现了 <code>__hash__()</code> 方法之后，如果我们指定一个确定的值作为所有对象的 <code>hash</code> 的结果，这时候 <code>s</code> 就只有一个元素了，因为这个此时两个对象再进行比较的时候，通过 <code>__eq__()</code> 方法，但是此时两个对象的 <code>__hash__()</code> 都返回的是 <code>1</code> 因此就判定这两个对象是同一个，所以在 <code>set</code> 中只有一个了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self) == hash(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> id(self)</span><br><span class="line"></span><br><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">t1 = TestObject(<span class="number">1</span>)</span><br><span class="line">t2 = TestObject(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s.add(t1)</span><br><span class="line">s.add(t2)</span><br><span class="line">print(s)</span><br><span class="line">print(t1 <span class="keyword">is</span> t2)</span><br></pre></td></tr></table></figure><p><b>字典的定义</b></p><p>字典 <code>dict</code> 是一种映射类型的数据，我们可以用 <code>isinstance(obj, abc.Mapping)</code> 来判断任何一种对象是不是广义上的映射类型，这里的 <code>obj</code> 可以是内置的任何一种数据，当然也可是我们自己定义的任何一种数据。</p><p><b>构造一个字典</b></p><p>构造一个字典可以有很多种不同的形式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict(zip([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    (<span class="string">'a'</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">'b'</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">'c'</span>, <span class="number">3</span>)</span><br><span class="line">]</span><br><span class="line">d = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> data&#125;</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p><b><code>collections.defaultdict</code> 和 <code>collections.OrderedDict</code></b></p><p><code>collections</code> 是一个数据类型容器模块。<br>有关 <a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" target="_blank" rel="noopener"><code>defaultdict</code></a> 和 <a href="https://docs.python.org/3.7/library/collections.html#collections.OrderedDict" target="_blank" rel="noopener"><code>OrderedDict</code></a> 的介绍和草看使用可以参阅文档。</p><p><b><code>dict</code> <code>defaultdict</code> 和 <code>OrderedDict</code> 对比</b></p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">说明</th><th style="text-align:center">dict</th><th style="text-align:center">defaultdict</th><th style="text-align:center">OrderedDict</th></tr></thead><tbody><tr><td style="text-align:center"><code>d.__contains__(k)</code></td><td style="text-align:center"><code>k in d</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__copy__()</code></td><td style="text-align:center"><code>copy.copy(d)</code></td><td style="text-align:center">✗</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>d.__len__()</code></td><td style="text-align:center"><code>len(d)</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__setitem__(k, v)</code></td><td style="text-align:center"><code>d[k] = v</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__getitem__(k)</code></td><td style="text-align:center"><code>v = d[k]</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__delitem__(k)</code></td><td style="text-align:center"><code>del d[k]</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__iter__()</code></td><td style="text-align:center"><code>key</code>的迭代器</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.keys()</code></td><td style="text-align:center">获取所有<code>key</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.values()</code></td><td style="text-align:center">获取所有<code>value</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.copy()</code></td><td style="text-align:center">浅拷贝</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.clear()</code></td><td style="text-align:center">清空所有数据</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.update(m, [**kargs])</code></td><td style="text-align:center"><code>m</code> 是映射或者键值对迭代器，更新 <code>d</code> 里对应的条目</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.fromkeys(it, [initial])</code></td><td style="text-align:center">迭代器 <code>it</code> 里的元素设置为映射里的 <code>key</code>，可选 <code>initial</code> 参数，作为这些键对应的值(默认 <code>None</code>)</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.setdefault(k, [default])</code></td><td style="text-align:center">如果有键 <code>k</code>，把它的值设置为 <code>default</code> ，否则 <code>d[k] = default</code>，返回 <code>default</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.get(k, [default])</code></td><td style="text-align:center">返回 <code>k</code> 对应的值，如果没有 <code>k</code>，则返回 <code>default</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.pop(k, [defaul]</code></td><td style="text-align:center">返回 <code>k</code> 所应的值，弹出这个<code>k-v</code>。如果没有这个<code>k</code>，返回 <code>defaul</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.items()</code></td><td style="text-align:center">返回 <code>d</code> 里所有的 <code>k-v</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.popitem()</code></td><td style="text-align:center">随机弹出一个 <code>k-v</code> 对。会移除字典里最先插入的元素(FIFO)；可选 <code>last</code> 参数为<code>True</code>，弹出最后插入的元素(LIFO)。</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__missing__(k)</code></td><td style="text-align:center">当 <code>__getitem__</code> 找不到对应 <code>k</code> 的时候会被调用</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>d.default_factory</code></td><td style="text-align:center">在 <code>__missing__</code> 函数中用以给未找到的元素设置值</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>d.move_to_end(k, [last])</code></td><td style="text-align:center">把 <code>k</code> 的元素移动到最前或最后(<code>last</code> 默认 <code>True</code>)</td><td style="text-align:center">✗</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>d.__reversed__()</code></td><td style="text-align:center">返回倒序的 <code>key</code> 的迭代器</td><td style="text-align:center">✗</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td></tr></tbody></table><p><b>集合 <code>set</code> </b></p><p><img src="https://zranbo.oss-cn-beijing.aliyuncs.com/blog/set-uml.png" alt></p><p>集合是许多唯一对象的聚合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'spam'</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'spam'</span>]</span><br><span class="line">s = set(l)</span><br><span class="line">print(list(s))</span><br></pre></td></tr></table></figure></p><p>集合中的元素必须是可散列的，<code>set</code> 类型本身是不可散列的，但是 <code>frozenset</code> 可以。所以可以创建一个包含不同 <code>frozenset</code> 的 <code>set</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 标签插件</title>
      <link href="/item/b32026b8/"/>
      <url>/item/b32026b8/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo内置"><a href="#Hexo内置" class="headerlink" title="Hexo内置"></a>Hexo内置</h1><p><b>引用块 (blockquote)</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><hr><p><b>Pull Quote</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><blockquote class="pullquote Wide Awake"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p></blockquote><h1 id="NexT-内置"><a href="#NexT-内置" class="headerlink" title="NexT 内置"></a>NexT 内置</h1><p><b>Bootstrap Callout</b></p><ul><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] %&#125; Content &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>class为一下之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">primary</span><br><span class="line">success</span><br><span class="line">info</span><br><span class="line">warning</span><br><span class="line">danger</span><br></pre></td></tr></table></figure></li><li><p>效果</p></li></ul><div class="note default"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note primary"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note success"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note info"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note warning"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div><div class="note danger"><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. </p></div>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的Python - 序列构成的数组 (二)</title>
      <link href="/item/2e88435f/"/>
      <url>/item/2e88435f/</url>
      
        <content type="html"><![CDATA[<p><b>序列类型概念</b></p><p>谈起序列，我们能说的就有很多了，比如我们很常用的<code>str</code> , <code>list</code> , <code>tuple</code> 等，Python用C语言实现了丰富的序列类型：</p><ul><li><p>容器序列（这些序列可以存放不同类型的数据）</p><p><code>list</code> <code>tuple</code> 等</p></li><li><p>扁平序列（这些序列只能存放同一种类型数据）</p><p><code>str</code> <code>bytes</code> <code>bytearray</code> <code>memoryview</code> <code>array.array</code> 等</p><p>这里需要注意一下点的是，对于容器序列，里面存放的是任意类型的对象的<b>引用</b>，而扁平序列是一串连续的内存空间，保存的是这些数据的值。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val = [<span class="number">1</span>]</span><br><span class="line">ctn = [val]</span><br><span class="line"></span><br><span class="line">print(ctn)</span><br><span class="line">val.append(<span class="number">2</span>)</span><br><span class="line">print(ctn)</span><br></pre></td></tr></table></figure><p><b>列表推导式</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"hello world"</span></span><br><span class="line">lst = [x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> string]</span><br></pre></td></tr></table></figure></p><p>这是一个很简单的列表推导式，当然，如果我们需要一些复杂的东西，可以这样变化一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'pink'</span>]</span><br><span class="line">sizes = [<span class="string">'M'</span>, <span class="string">'L'</span>, <span class="string">'XL'</span>]</span><br><span class="line"></span><br><span class="line">goods = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line">print(goods)</span><br><span class="line">goods = [(color, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes <span class="keyword">for</span> color <span class="keyword">in</span> colors]</span><br><span class="line">print(goods)</span><br></pre></td></tr></table></figure><p>调换了一下后面迭代的先后顺序，可以看到结果有了变化。</p><p><b>生成器表达式</b></p><p>从使用上来说，和列表推导式没有太大的区别，只是将<code>[ ]</code>换成<code>( )</code>。<br>列表推导式最终得到的是一个列表对象，而生成器表达式是一个元组对象。</p><p><b>元组不仅仅是不可变的列表</b></p><p>元组的一个特殊之处是对象一旦被创建，就不能更改，包括值和值所在的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">t2 = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">t3 = (<span class="string">'b'</span>, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">print(t1 <span class="keyword">is</span> t2)</span><br><span class="line">print(t1 <span class="keyword">is</span> t3)</span><br></pre></td></tr></table></figure><p>正因为这个，元组就变得有点意思了，因为除了具体的值，元组还可以比列表多记录一项内容：这些数据的位置也可以用来保存一定的信息。</p><p><b>序列的拆包</b></p><p>注意这里我们并没有用元组的拆包，那是因为并不是只有元组才能拆包，而是一般的，对于大多数Python的序列，我们都可以这要去做<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eg = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">ele1, ele2, ele3 = eg</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">egl = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">ele1, ele2, ele3 = egl</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">eg2 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">ele1, ele2, ele3 = eg2</span><br><span class="line">print(ele1, ele2, ele3)</span><br><span class="line"></span><br><span class="line">eg3 = <span class="string">'abc'</span></span><br><span class="line">ele1, ele2, ele3 = eg3</span><br><span class="line">print(ele1, ele2, ele3)</span><br></pre></td></tr></table></figure></p><p>值得注意的一点是，对于字典 <code>dict</code> 的拆包，并不是把 <code>key-value</code> 这个键值对拿出来了，而只是把 <code>key</code> 拆开了，其实对于这个我们一点也不惊讶，毕竟如果我们需要对字典的 <code>key-value</code> 都进行迭代，并不是 <code>for data in dict</code> 而是 <code>for k, v in dict.items()</code> 注意观察到其实我们也发现了，这里不就是用了对字典的 <code>key-value</code> 拆包的方法么？</p><p><b>序列拆包中 <code>*</code> 的作用</b></p><p>对于拆包过程中，我们可以使用 <code>*</code> 来包含多个元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>)</span><br><span class="line">ele1, ele2, *eles = t</span><br><span class="line">print(ele1, ele2, eles)</span><br></pre></td></tr></table></figure></p><p>而 <code>*</code> 表示的多个元素则会放到一个列表中去。</p><p>而且这个 <code>*</code> 可以放到中间表示出了首末若干元素的其他所有元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>)</span><br><span class="line">ele1, ele2, *eles, ele3 = t</span><br><span class="line">print(ele1, ele2, eles, ele3)</span><br></pre></td></tr></table></figure></p><p><b>元组和列表的区别</b></p><p>这里的区别体现在一些内置的属性方法上。列表说明</p><table><thead><tr><th style="text-align:center">属性方法</th><th style="text-align:center">说明</th><th style="text-align:center">列表</th><th style="text-align:center">元组</th></tr></thead><tbody><tr><td style="text-align:center"><code>s.__getnewargs__()</code></td><td style="text-align:center"><code>pickle</code> 中支持更加优化的序列化</td><td style="text-align:center">✗</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__add__(s2)</code></td><td style="text-align:center"><code>s + s2</code>，拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__contains__(e)</code></td><td style="text-align:center"><code>s</code> 是否包含 <code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.index(e)</code></td><td style="text-align:center">在 <code>s</code> 中找到元素 <code>e</code> 第一次出现的位置</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.count(e)</code></td><td style="text-align:center"><code>e</code> 在 <code>s</code> 中出现的次数</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__getitem__(p)</code></td><td style="text-align:center"><code>s[p]</code>，获取位置 <code>p</code> 的元素</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__iter__()</code></td><td style="text-align:center">获取 <code>s</code> 的迭代器</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__len__()</code></td><td style="text-align:center"><code>len(s)</code>，元素的数量</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__mul__(n)</code></td><td style="text-align:center"><code>s * n</code>，<code>n</code> 个 <code>s</code> 的重复拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__rmul__(n)</code></td><td style="text-align:center"><code>n * s</code>，反向拼接 *</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center"><code>s.__delitem__(p)</code></td><td style="text-align:center">把位于 <code>p</code> 的元素删除</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__reversed__()</code></td><td style="text-align:center">返回 <code>s</code> 的倒序迭代器</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__setitem__(p, e)</code></td><td style="text-align:center"><code>s[p] = e</code>，把元素 <code>e</code> 放在位置 <code>p</code>，替代已经在那个位置的元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__imul__(n)</code></td><td style="text-align:center"><code>s *= n</code>，就地重复拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.__iadd__(s2)</code></td><td style="text-align:center"><code>s += s2</code>，就地拼接</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.insert(p, e)</code></td><td style="text-align:center">在位置 <code>p</code> 之前插入元素<code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.append(e)</code></td><td style="text-align:center">在尾部添加一个新元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.clear()</code></td><td style="text-align:center">删除所有元素</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.copy()</code></td><td style="text-align:center">浅复制</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.extend(it)</code></td><td style="text-align:center">把可迭代对象 <code>it</code> 追加给 <code>s</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.pop([p])</code></td><td style="text-align:center">删除最后或者是（可选的）位于 <code>p</code> 的元素，并返回它的值</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.remove(e)</code></td><td style="text-align:center">删除 <code>s</code> 中的第一次出现的 <code>e</code></td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.reverse()</code></td><td style="text-align:center">就地倒序</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center"><code>s.sort([key], [reverse])</code></td><td style="text-align:center">就地对 <code>s</code> 中的元素进行排序，可选的参数有键（<code>key</code>）和是否倒序（<code>reverse</code>）</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的Python - Python数据模型 (一)</title>
      <link href="/item/1bbbb445/"/>
      <url>/item/1bbbb445/</url>
      
        <content type="html"><![CDATA[<p><b>Magic Method (Dunder Method)</b></p><div class="note info"><p>Python 里面有很多特殊方法，我们管他叫魔术方法(magic method)。之所以特殊，是因为这些方法不同于一般的对象方法的调用方式 <code>Object.function</code>，比如对于获取字符串对象 <code>s = &quot;Hello&quot;</code> 的长度,不同于其他一些语言的 <code>s.length()</code> 或者类似的方法，Python采用 <code>len(s)</code> 这样的形式。 </p></div><blockquote><p>首先明确一点，特殊方法的存在是为了被 Python 解释器调用的，你自己并不需要调用它们。也就是说没有 <code>my_object.__len__()</code> 这种写法，而应该使用 <code>len(my_object</code>)。在执行 <code>len(my_object)</code> 的时候，如果 <code>my_object</code> 是一个自定义类的对象，那么 Python 会自己去调用其中由你实现的 <code>__len__</code> 方法。</p><footer><strong>——Fluent Python</strong></footer></blockquote><p>而 Python 里面这样的特殊方法还有很多，列一个表格说明一些。</p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:left">方法名</th></tr></thead><tbody><tr><td style="text-align:center">字符串/字节序列表示形式</td><td style="text-align:left"><code>__repr__</code>、<code>__str__</code>、<code>__format__</code>、<code>__bytes__</code></td></tr><tr><td style="text-align:center">数值转换</td><td style="text-align:left"><code>__abs__</code>、<code>__bool__</code>、<code>__complex__</code>、<code>__int__</code>、<code>__float__</code>、<code>__hash__</code>、<code>__index__</code></td></tr><tr><td style="text-align:center">集合模拟</td><td style="text-align:left"><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td></tr><tr><td style="text-align:center">迭代枚举</td><td style="text-align:left"><code>__iter__</code>、<code>__reversed__</code>、<code>__next__</code></td></tr><tr><td style="text-align:center">可调用模拟</td><td style="text-align:left"><code>__call__</code></td></tr><tr><td style="text-align:center">上下文管理</td><td style="text-align:left"><code>__enter__</code>、<code>__exit__</code></td></tr><tr><td style="text-align:center">实例创建和销毁</td><td style="text-align:left"><code>__new__</code>、<code>__init__</code>、<code>__del__</code></td></tr><tr><td style="text-align:center">属性管理</td><td style="text-align:left"><code>__getattr__</code>、<code>__getattribute__</code>、<code>__setattr__</code>、<code>__delattr__</code>、<code>__dir__</code></td></tr><tr><td style="text-align:center">属性描述符</td><td style="text-align:left"><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td></tr><tr><td style="text-align:center">类相关服务</td><td style="text-align:left"><code>__prepare__</code>、<code>__instancecheck__</code>、<code>__subclasscheck__</code></td></tr></tbody></table><p>上面表格里面列举的并不是所有的，还有很多比如与运算相关的特殊方法 <code>__add__</code> 、 <code>__abs__</code> 等都没有列举。</p><p><b>一些常用操作对应的魔术方法</b></p><ul><li><p><code>for</code> 迭代操作</p><p>如果一个对象可以通过 <code>for</code> 循环，需要实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法，并且需要在 <code>__next__()</code> 中通过抛出 <code>StopIteration</code> 异常来控制 <code>for</code> 的终止行为:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init=<span class="number">0</span>, stop=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.init = init</span><br><span class="line">        self.data = init</span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.data &gt;= self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data</span><br><span class="line">            </span><br><span class="line">obj = tObject()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><ul><li><p><code>in</code> 操作</p><p>用 <code>in</code> 判断对象关系的时候，需要实现 <code>__contains__()</code>，但是如果没有实现 <code>__contains__()</code> ，会进行一次迭代操作：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init=<span class="number">0</span>, stop=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.init = init</span><br><span class="line">        self.data = init</span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.data &gt;= self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.init &lt; key &lt; self.stop:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">obj = tObject()</span><br><span class="line"></span><br><span class="line">print(<span class="number">5</span> <span class="keyword">in</span> obj)</span><br></pre></td></tr></table></figure><p>但是如果没有实现 <code>__contains__()</code> 这里这里就会首先进行一次迭代操作，然后去判断。</p><ul><li><p><code>print()</code>或<code>str()</code></p><p><code>__repr__()</code>的目的应该是能准确表达出对象。</p><p><code>__str__()</code>的目的是能友好的可读的表达对象。</p></li></ul><ul><li><p><code>[]</code> 取值&amp;赋值&amp;操作</p><p>分别是 <code>__getitem__()</code> 和 <code>__setitem__()</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data.get(key, <span class="string">'N/A'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        self.data[key] = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = tObject()</span><br><span class="line">obj[<span class="string">'1'</span>] = <span class="string">'a'</span></span><br><span class="line">print(obj[<span class="string">'1'</span>])</span><br></pre></td></tr></table></figure><p><code>__getitem__()</code> 方法用于返回参数 <code>key</code> 所对应的值，这个 <code>key</code> 可以是索引，关键字或切片对象，并且支持负数索引；如果 <code>key</code> 不是以上两种类型，就会抛出 <code>TypeError</code> ；如果索引越界，会抛 <code>IndexError</code> ；如果定义的是映射类型，当 <code>key</code> 参数不是其对象的键值时，则会抛出 <code>KeyError</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/item/4a17b156/"/>
      <url>/item/4a17b156/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Void </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
